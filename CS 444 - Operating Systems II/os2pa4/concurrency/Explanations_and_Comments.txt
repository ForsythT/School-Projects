Part 1 uses a semaphore from the semaphore.h library to control the number of threads which can access the data at a given time. At max, 3 threads can be using the data. In the thread's function, it first tries to lock the semaphore, and if it is successful then it will begin doing work on the thread. For simplicity, the "work" that it does is to simply add all values in the array. If there is already 3 threads using the data, it must wait. Once the threads complete their work, they post the semaphore, indicating that another thread may take its place.

In part 2, we used 2 mutexes, 1 for deleters and 1 for inserters, as well as 3 global variables indicating what threads are active at any point in time. A searcher may search the list any time that a deleter is not active. If one is active, it sleeps until the deleter is done. Inserters work one at a time, but can be concurrent with searchers. One inserter locks the mutex and inserts only if a deleter is not active. If one is active, it sleeps until it is done. Finally, deleters can only delete when there are no other deleters, searchers, or inserters active, and it will sleep until these conditions are met.
